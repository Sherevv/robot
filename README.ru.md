# Robot

Робот на клетчатом поле. Имеется несколько разновидностей роботов: с абсолютной ориентацией по сторонам света и с относительной ориентацией.

[English version](README.md)

# Оглавление

* [Зависимости](#Зависимости)
* [Установка](#Установка)
* [Описание класса Robot](#Описание-класса-Robot)
    * [Методы класса Robot](#Методы-класса-Robot)
* [Описание класса RobotOrt](#Описание-класса-RobotOrt)
    * [Методы класса RobotOrt](#Методы-класса-RobotOrt)
* [Описание класса RobotRot](#Описание-класса-RobotRot)
    * [Методы класса RobotRot](#Методы-класса-RobotRot)
* [Пример использования](#Пример-использования)
* [Использование интерактивной консоли python](#Использование-интерактивной-консоли-python)
* [Использование в Jupyter](#Использование-в-Jupyter)
* [Работа с интерфейсом](#Работа-с-интерфейсом)
    * [Кнопки управления](#Кнопки-управления)
    * [Управление с клавиатуры](#Управление-с-клавиатуры)
* [Жук](#Жук)
    
# Зависимости
Версии пакетов, на которых тестировалось указаны в скобках.
- Python 3.7 и выше (3.7)
- tkinter (8.6.9, входит в стандартный дистрибьютив Python; в Linux, возможно, придется устанавливать отдельно)
- numpy (1.17.4)
- matplotlib (3.1.1)


# Установка

Все команды выполняются в командной строке.

**Вариант первый.** Клонируем репозиторий и переходим в созданную директорию 

```commandline
git clone https://github.com/Sherevv/robot.git robot

cd robot
```

и выполняем команду:
```
python setup.py install
```
или
```
pip install .
```

**Второй вариант.** Установка с помощью pip из удаленного репозитория:

```
pip install git+https://github.com/Sherevv/robot.git
```

# Описание класса Robot
```python
r = Robot() # 1
r = Robot( mapfile ) # 2
r = Robot( delay=0.5 ) # or r = Robot(None, 0.5 ) # 3
params = {'delay': 0.2, 'size': [10, 5], 'frame': True}
r = Robot(**params) # 4
```
В 1-ом случае открвается стандартное диалоговое окно для 
выбора существующей файла, в случае отказа, открывается диалог для
сохранения нового файла, иначе создается стандартное поле, но при этом будет не доступно управление роботом пока вы не сохраните обстановку.

Во 2-м случае:
 - `mapfile` - имя файла, в котором сохранена обстановка на поле

Во 3-м случае:
 - `delay` - временная задержка при анимации (по умолчанию `0.5` секунд)
 
Во 4-м случае передается словарь параметров:
 - `size`  - размеры поля в виде списка `[высота, ширина]` (по умолчанию `[5, 3]`)
 - `frame` - включена ли рамка поля (по умолчанию `True`)
 
## Методы класса Robot

**`step(side)`** - команда переместить робота в соседнюю клетку в заданном направлении `side`

**`mark()`** - команда поставить маркер в клетку с роботом

**`is_mark()`** - команда проверить наличие маркера клетки поля

**`is_bord(side)`** -  команда проверить наличие перегородки в заданном направлении `side`

**`get_tmpr()`** - команда измерить и сообщить "температуру" текущей клетки

Параметр `side` может принимать значения `'n'`, `'s'`, `'w'`, `'o'`, соответствующие сторонам света: север, юг, запад, восток

Дополнительные методы для работы с полем, аналогичны функционалу контролов управления:

**`_is_frame()`** - проверка, есть ли внешняя рамка (стена) поля

**`_frame_on()`, `_frame_off()`** - добавляет/удаляет внешнюю рамку поля

**`_set_field_size(size)`** -  создает новое поел заданного размера `size = [coln, rown]`

**`_set_field_coln(coln)`** - задает новую высоту поля `coln`

**`_set_field_rown(rown)`** - задает новую ширину поля `rown`

**`_restore_field()`** -  восстанавливает состояние поля из файла

**`_save_field()`** - сохраняет состояние поля в файла

**`_delay_on()`, `_delay_off()`** - включает/выключает временную задержку 

**`_tmpr_on()`, `_tmpr_off()`** -  включает/выключает отображения температуры клеток

**`_remove_borders()`** -  удаляет все перегородки с поля (кроме рамки)

**`_remove_markers()`** - удаляет все маркеры с поля

**`_effects_on()`, `_effects_off()`** -  включает/выключает визуализации проверки поля роботом

# Описание класса RobotOrt

Представляет исполнителя "ориентированнный робот на клетчатом поле".
Направление перемещения, поворотов и проверки наличия препятствия задаются
**относительно**: 
- шаг вперед; 
- повернуть налево; 
- повернуть направо;
- проверить, есть ли препятствие прямо по курсу.

## Методы класса RobotOrt

**`forward()`** - команда переместить робота вперед в соседнюю клетку 

**`right()`** - команда развернуть робота вправо 

**`left()`** - команда развернуть робота влево 

**`is_bord()`** -   команда проверить наличие перегородки впереди робота

**`get_side()`** - команда сообщить текущее направление робота

Методы **`mark()`**, **`is_mark()`**, **`get_tmpr()`** - соответствуют методам класса `Robot`

# Описание класса RobotRot

Отличается от класса `RobotRot` тем, что вместо двух методов `left` и
`right` в классе `RobotRot` имеется лишь один метод `rot`, но с параметром,
который может принимать 3 значения: `'left'`, `'right'`, `'back'` (или `'l'`,
`'r'`,`'b'`)
а также тем, что метод `is_bord` имеет параметр, который может
принимать также 3 значения: `'forward'`, `'left'`, `'right'`


## Методы класса RobotRot

**`rot(side)`** - команда развернуть робота вправо 

**`is_bord(side)`**` -   команда проверить наличие перегородки в заданном направлении

Остальные методы те же, что и у класса `RobotOrt`.

# Пример использования

Создайте python скрипт, например `start.py`
```python
from robot import Robot, RobotOrt, RobotRot

r = Robot()             # Создаем робота
if not r.is_mark():     # Проверяем, замаркирована ли текущая клетка
    r.mark()            # Ставим маркер
if not r.is_bord('w'):  # Проверяем, есть ли препятствие на западе
    r.step('w')         # Шагаем на запад
print(r.get_tmpr())     # Выводим температуру в текущей клетке


ro = RobotOrt()         # Создаем ориентированного робота
if not ro.is_bord():    # Проверяем, есть ли препятствие перед роботом
    ro.forward()        # Шагаем вперед
ro.right()              # Поворачиваем робота направо
if not ro.is_bord():    # Проверяем, есть ли препятствие перед роботом
    ro.forward()        # Шагаем вперед    
print(ro.get_side())    # Выводим текущую ориентацию робота


rt = RobotRot()                # Создаем ориентированного робота
if not rt.is_bord('forward'):  # Проверяем, есть ли препятствие перед роботом
    rt.forward()               # Шагаем вперед
if not rt.is_bord('right'):    # Проверяем, есть ли препятствие справа от робота
    rt.rot('r')                # Поворачиваем робота направо
    rt.forward()               # Шагаем вперед   
print(rt.get_side())           # Выводим текущую ориентацию робота


input()  # для предотвращения закрытия окна после отрисовки
```

затем вызываете исполнение скрипта в командной строке
```commandline
python start.py
```

[Примеры кода](robot/examples)

# Использование интерактивной консоли python

Подготовьте python файл с функцией (например, файл `myfunc.py`):
```python
def walk_to_bord(r, side):
    """ 
    Робот идет пока не встретит стенку в заданном направлении
    
    :param r     - ссылка на объект робота
    :param side  - направление движения = 'n' (Север) | 's' (Юг) | 'o' (Восток) | 'w' (Запад)
    """
    while not r.is_bord(side):
        r.step(side)
```

затем запускаем консоль python
```commandline
python
```
и выполняем следующие команды

```python
>>> from robot import Robot
>>> from myfunc import walk_to_bord
>>> r = Robot()
>>> walk_to_bord(r, 'o')
```

# Использование в Jupyter

Для запуска робота в блокноте Jupyter необходимо использовать магические команды для matplotlib.
Чтобы робот запускался в отдельном окне, можно использовать команду `%matplotlib` с параметром`tk`:
```python
%matplotlib tk
from robot import Robot
r = Robot()
...
```

Чтобы робот отображался непосредственно в блокноте, необходимо использовать параметр `widget`
```python
%matplotlib widget
```
Для работы параметра `widget` нужно установить расширене [jupyter-matplotlib](https://github.com/matplotlib/jupyter-matplotlib).

# Работа с интерфейсом

При создании экземпляра робота появляется окно с полем и роботом:
![Пример поля с роботом стенками и маркером](figure.png)

Изменить ( установить или отредактировать ) начальную обстановку
на поле можно с помощью мыши:
 - клик по клетке устанавливает маркер 
 - клик по маркеру удаляет маркер
 - клик по пунктирной линии сетки клетчатого поля устанавливает
 перегородку
 - клик по перегородке удаляет перегородку
 - клик по роботу и перемещение мыши при неотпущенной клавише
 перемещает робота вслед за курсором в нужную клетку
 ( "неисправного" робота также можно "починить" таким способом )
 
После любого числа таких действий необходимо сохранить состояние, после чего робот готов к командному управлению.

## Кнопки управления

В окне имеются кнопки для управления полем и его состоянием, ими можно управлять с клавиатуры (клавиши указаны в скобках).

![Добавить столбец](robot/robot_engine/tools/icons8-add-column-32.png) - увеличивает поле на один столбец (клавиша `w`)

![Удалить столбец](robot/robot_engine/tools/icons8-delete-column-32.png) - уменьшает поле на один столбец (клавиша `e`)

![Добавить строку](robot/robot_engine/tools/icons8-add-row-32.png) - увеличивает поле на одну строку (клавиша `h`)

![Удалить строку](robot/robot_engine/tools/icons8-delete-row-32.png) - уменьшает поле на одну строку (клавиша `j`)

![Удалить все перегородки](robot/robot_engine/tools/icons8-close-program-32.png) - удаляет с поля все перегородки (комбинация `ctrl + b`)

![Удалить все маркеры](robot/robot_engine/tools/icons8-broom-32.png) - удаляет с поля все маркеры (комбинация `ctrl + m`)

![Добавить/удалить рамку](robot/robot_engine/tools/icons8-add-image-32.png) - добавляет/удаляет внешнюю рамку поля (клавиша `b`)

![Показать/скрыть температуру](robot/robot_engine/tools/icons8-text-box-32.png) - включает/выключает отображения температуры клеток (клавиша `t`)

![Включить/выключить задержку](robot/robot_engine/tools/icons8-speedometer-32.png) - включает/выключает временную задержку и эффекты анимации (клавиша `d`)

![Восстановить состояние](robot/robot_engine/tools/icons8-sync-32.png) - восстанавливает состояние поля из файла (клавиша `r`)

![Сохранить состояние](robot/robot_engine/tools/icons8-save-32.png) - сохраняет состояние поля в файла (без отображения диалога) (клавиша `s`)

![Сохранить состояние как](robot/robot_engine/tools/icons8-save-as-32.png) - сохраняет состояние поля в файла (комбинация `ctrl + s`)

![Открыть файл](robot/robot_engine/tools/icons8-open-32.png) - загружает состояние поля из файла (комбинация `ctrl + l`)

## Управление с клавиатуры

Основные клавиши для управления полем указаны выше.

Кроме этого работают следующие комбинации:

`ctrl + '+'` - увеличивает временную задержку в 2 раза

`ctrl + '-'` - уменьшает временную задержку в два раза

`ctrl + r`  - перемещает робота в левый нижний угол

# Жук

Имеется класс для задачи "Жук в лабиринте" (оригинал задачи [тут](http://buglab.ru)). Изначально жук находится в левом верхнем углу, выход находится в правой нижней клетке. Жук двигается самостоятельно в поисках выхода по определенному алгоритму. Необходимо построить такой лабиринт, в котором жук будет плутать максимально долго. Обязательно должен существовать проход до выхода, и поле должно иметь внешнюю стенку.

Использование:
```python
from robot.bug import Bug

b = Bug('bug.map', delay=0.0001)  # или просто Bug()
b.go()  # запуск жука


input()  # для предотвращения закрытия окна после отрисовки
```