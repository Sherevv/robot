import os
import matplotlib.pyplot as plt
from .robot_engine import RobotEngine
from .robot_engine.exeptions import (RobotException, WindowClosedError,
                                     MapfileExtensionError, NotSaveError,
                                     SideRotValueError)
from .robot_engine.helpers import eprint, mapfile_check
from .robot_engine import star_control
from .robot_engine.encode_side import encode_side
from .robot_engine.decode_side import decode_side


class RobotBase:

    def __init__(self, mapfile=None):
        """
        Robot - The constructor of a class

        SYNTAX:
           r = Robot()
           r = Robot( mapfile )
        WHERE:
        - mapfile = Name of a mat-file with initial conditions
        - r = The reference to the created object

        -------------------------------------------------------------
        All methods of a class Robot:
         step, is_bord, mark, is_mark, get_tmpr

        :param mapfile: Name of a mat-file with initial conditions

        #
        # Robot - конструктор класса
        #
        # СИНТАКСИС:
        #       r = Robot()
        #       r = Robot( mapfile )
        #
        # В 1-ом случае открвается стандартное диалоговое окно для
        # выбора файла, в случае отказа, открывается диалог для
        # определения параметров поля
        #
        # Во 2-м случае:
        # - mapfile - имя файла, в котором сохранена обстановка на поле
        #
        # РЕЗУЛЬТАТ:
        # - r = ссылка ( handle ) на созданный объект класса Robot
        #
        # -------------------------------------------------------------
        # Kомандный интерфейс робота ( методы класса ):
        #     step, is_bord, mark, is_mark, get_tmpr
        #
        # --------------------------------------------------------------
        # Изменить ( установить или отредактировать ) начальную обстановку
        # на поле можно с помощью мыши:
        #  -клик по клетке устанавливает маркер
        #  -клик по маркеру удаляет маркер
        #  -клик по пунктирной линии сетки клетчатого поля устанавливает
        #  перегородку
        #  -клик по перегородке удаляет перегородку
        #  -клик по роботу и перемещение мыши при неотпущенной клавише
        #  перемещает робота вслед за курсором в нужную клетку
        #  ( "неисправного" робота также можно "починить" таким способом )
        # После любого числа таких действий робот сразу готов к командному
        # управлению
        #
        # -------------------------------------------------------------
        # Если r.outside = 'none', то считается, что поле ограничено рамкой
        #     r.outside = 'ismark', то считается, что за пределами рамки сплошь установлены маркеры
        #     r.outside = 'nomark', то считается, что за пределами рамки исходно маркеров нет
        #
        # При r.outside не равном 'none' считается, что все перегородки, вплотную примыкающие к рамке поля
        # ( которая в данном случае не рассматривается как ограждение ),
        # мыслятся продолженными до бесконечности в невидимую часть поля в соответствующих направлениях
        # ( невидимая часть поля всегда остается невидимой )
        #
        # -------------------------------------------------------------
        # Сохранить результат РУЧНОГО редактирования обстановки на поле
        # можно с помощью комбинации клавиш CTRL+S
        # ( при этом окно с роботом должно быть текущим! )
        #
        # Восстановить последнюю сохраненную обстановку на поле можно с помощью
        # комбинации клавиш CTRL+R ( при этом окно с роботом должно быть текущим! )
        #
        # Просмотреть значения температур клеток можно с помощью коьбинации клавиш
        # CRTL+T ( при этом окно с роботом должно быть текущим! )
        # Повторное нажатие этой комбинации клавиш убирает значения температур из
        # клеток.
        # Визуализированные значения температур можно редактировать ( результаты редактирования
        # сохраняются только в опреративной памяти, для сохранения на диске
        # требуется CTRL+S )
        #
        # Динамически менять время задержки выполнения команд робота мможно с помощью
        # комбинации клавиш CTRL+"плюс" или CTRL+"минус", соответственно
        # ( при этом окно с роботом должно быть текущим! )

        # hRobotEngine - ссылка на объект класса RobotEngine (робот на клетчатом поле)
        """
        if not mapfile:
            mapfile = ''
        else:  # checks mapfile
            try:
                mapfile_check(mapfile)
            except (ValueError, MapfileExtensionError, FileNotFoundError) as e:
                eprint(e)
                return

        self.mapfile = mapfile

        self.hRobotEngine = None

        self.init_data()

        if self.hRobotEngine:
            self.hRobotEngine.hField.hFig.robotdata = self

    def init_data(self):
        """
        Initialize data
        :return:
        """
        # self.hRobotEngine = RobotEngine(self.mapfile, 'Robot')
        pass

    def step(self, side):
        """step - Moves the Robot on one step to the set side

        SYNTAX:
                   r.step( side )

        WHERE:
         - side = 'n' | 's' | 'o' | 'w'
         - r = The handle to object of class Robot
        """

        try:
            self.robot_check()
            self.hRobotEngine.step(side)
        except RobotException as e:
            eprint(e)

    def mark(self):
        """
        Puts a marker in a current cage

        SYNTAX:
                r.mark()

        WHERE:
         - r = The handle to object of class Robot
        """

        try:
            self.robot_check()
            self.hRobotEngine.mark()
        except RobotException as e:
            eprint(e)

    def is_mark(self):
        """
        Returns result of stock-taking of a marker in a current cage

        SYNTAX:
                    ansv = r.is_mark()

        WHERE:
         - r = The handle to object of class Robot
         - ansv = True | False

        :return boolean
        """

        try:
            self.robot_check()
            return self.hRobotEngine.is_mark()
        except RobotException as e:
            eprint(e)

    def get_tmpr(self):
        """
        Returns value of temperature in a current cage

        SYNTAX:
                val = r.get_tmpr()

        WHERE:
         - r = The handle to object of class Robot

        :return temperature ( double )
        """

        try:
            self.robot_check()
            return self.hRobotEngine.get_tmpr()
        except RobotException as e:
            eprint(e)

    def robot_check(self):
        """
        Make checks for correct robot work
        """
        if not plt.fignum_exists(self.hRobotEngine.hField.hFig.number):
            raise WindowClosedError

        if star_control.is_star_to_end(self.hRobotEngine.hField.hFig):
            raise NotSaveError


class Robot(RobotBase):
    """
    Robot on a cellular field

    Directions of movement and obstacle checks are set ABSOLUTE values: North, South, West, East
    """

    def __init__(self, mapfile=None):
        """
        Robot - The constructor of a class

        SYNTAX:
           r = Robot()
           r = Robot( mapfile )
        WHERE:
        - mapfile = Name of a mat-file with initial conditions
        - r = The reference to the created object

        -------------------------------------------------------------
        All methods of a class Robot:
         step, is_bord, mark, is_mark, get_tmpr

        :param mapfile: Name of a mat-file with initial conditions

        #
        # Robot - конструктор класса
        #
        # СИНТАКСИС:
        #       r = Robot()
        #       r = Robot( mapfile )
        #
        # В 1-ом случае открвается стандартное диалоговое окно для
        # выбора файла, в случае отказа, открывается диалог для
        # определения параметров поля
        #
        # Во 2-м случае:
        # - mapfile - имя файла, в котором сохранена обстановка на поле
        #
        # РЕЗУЛЬТАТ:
        # - r = ссылка ( handle ) на созданный объект класса Robot
        #
        # -------------------------------------------------------------
        # Kомандный интерфейс робота ( методы класса ):
        #     step, is_bord, mark, is_mark, get_tmpr
        #
        # --------------------------------------------------------------
        # Изменить ( установить или отредактировать ) начальную обстановку
        # на поле можно с помощью мыши:
        #  -клик по клетке устанавливает маркер
        #  -клик по маркеру удаляет маркер
        #  -клик по пунктирной линии сетки клетчатого поля устанавливает
        #  перегородку
        #  -клик по перегородке удаляет перегородку
        #  -клик по роботу и перемещение мыши при неотпущенной клавише
        #  перемещает робота вслед за курсором в нужную клетку
        #  ( "неисправного" робота также можно "починить" таким способом )
        # После любого числа таких действий робот сразу готов к командному
        # управлению
        #
        # -------------------------------------------------------------
        # Если r.outside = 'none', то считается, что поле ограничено рамкой
        #     r.outside = 'ismark', то считается, что за пределами рамки сплошь установлены маркеры
        #     r.outside = 'nomark', то считается, что за пределами рамки исходно маркеров нет
        #
        # При r.outside не равном 'none' считается, что все перегородки, вплотную примыкающие к рамке поля
        # ( которая в данном случае не рассматривается как ограждение ),
        # мыслятся продолженными до бесконечности в невидимую часть поля в соответствующих направлениях
        # ( невидимая часть поля всегда остается невидимой )
        #
        # -------------------------------------------------------------
        # Сохранить результат РУЧНОГО редактирования обстановки на поле
        # можно с помощью комбинации клавиш CTRL+S
        # ( при этом окно с роботом должно быть текущим! )
        #
        # Восстановить последнюю сохраненную обстановку на поле можно с помощью
        # комбинации клавиш CTRL+R ( при этом окно с роботом должно быть текущим! )
        #
        # Просмотреть значения температур клеток можно с помощью коьбинации клавиш
        # CRTL+T ( при этом окно с роботом должно быть текущим! )
        # Повторное нажатие этой комбинации клавиш убирает значения температур из
        # клеток.
        # Визуализированные значения температур можно редактировать ( результаты редактирования
        # сохраняются только в опреративной памяти, для сохранения на диске
        # требуется CTRL+S )
        #
        # Динамически менять время задержки выполнения команд робота мможно с помощью
        # комбинации клавиш CTRL+"плюс" или CTRL+"минус", соответственно
        # ( при этом окно с роботом должно быть текущим! )

        # hRobotEngine - ссылка на объект класса RobotEngine (робот на клетчатом поле)
        """
        super().__init__(mapfile)

    def init_data(self):
        """
        Initialize data
        :return:
        """
        self.hRobotEngine = RobotEngine(self.mapfile, 'Robot')

    def step(self, side):
        """step - Moves the Robot on one step to the set side
        
        SYNTAX:
                   r.step( side )
        
        WHERE:
         - side = 'n' | 's' | 'o' | 'w'
         - r = The handle to object of class Robot
        """

        try:
            self.robot_check()
            self.hRobotEngine.step(side)
        except RobotException as e:
            eprint(e)

    def is_bord(self, side=None):
        """
        is_bord - Returns result of stock-taking of a border in the set side
            
            SYNTAX:
                      ansv = r.is_bord( side )
            
            WHERE:
             - side = 'n' | 's' | 'o' | 'w' 
             - r = The handle to object of class Robot
             - ansv = 1 ( true ) | 0 ( false ) 
        :param side: 
        :return: 
        """

        try:
            self.robot_check()
            return self.hRobotEngine.is_bord(side)
        except RobotException as e:
            eprint(e)


class RobotRelBase(RobotBase):
    """
    #Класс Rob_rot, каждый объект этого класса является
    #ссылкой ( handle ) на объект, представляющий
    #   ИСПОЛНИТЕЛЯ "ориентированнный робот на клетчатом поле"
    #
    #Командный интерфейс ( методы класса ):
    # forward, rot, is_bord, mark, is_mark, get_side, get_tmpr
    #
    #Направление перемещения, поворотов и проверки наличия препятствия задаются
    #ОТНОСИТЕЛЬНО:
    #   шаг вперед; повернуть налево; повернуть направо;
    #   проверить, есть ли препятствие прямо по курсу, слева, справа
    #
    #************************************************************************
    #ОТЛИЧАЕТСЯ от класса Rob_rel тем, что вместо двух методов Rob_rel\Left и
    #Rob_rel\Right в классе Rob_rot имеется лишь один метод rot, но с параметром,
    #который может принимать 3 значения: 'left', 'right', 'back' (или 'l',
    #'r','b')
    #а также тем, что метод Rob_rot\is_bord имеет параметр, который может
    #принимать также 3 значения: 'forward', 'left', 'right'
    #
    #-------------------------------------------------------------------------
    #Версия: 1.0*
    #Дата: 13.03.2013
    #-----------------------------------------------------------------------


    # Rob_rot - класс-оболочка класса Robot.Robot( )

    # % properties( Access = private )
    #hField# ссылка на объект класса Robot.Robot (робот на клетчатом поле)
    #end
    """

    def __init__(self, mapfile=None):
        """
        #Rob_rot - конструктор класса
        #
        #СИНТАКСИС:
        #       r = Rob_rot()
        #       r = Rob_rot( mapfile )
        #
        #В 1-ом случае открвается стандартное диалоговое окно для
        #выбора файла, в случае отказа, открывается диалог для
        #определения параметров поля
        #
        #Во 2-м случае:
        # - mapfile - имя файла, в котором сохранена обстановка на поле
        #
        #РЕЗУЛЬТАТ:
        # - r = ссылка ( handle ) на созданный объект класса Rob_rot
        #
        #-------------------------------------------------------------
        # Командный интерфейс робота ( методы класса ):
        #   forward, rot, is_bord, mark, is_mark, get_side, get_tmpr
        #
        #-------------------------------------------------------------
        #Изменить ( установить или отредактировать ) начальную обстановку
        #на поле можно с помощью мыши:
        #  -клик по клетке устанавливает маркер
        #  -клик по маркеру удаляет маркер
        #  -клик по пунктирной линии сетки клетчатого поля устанавливает
        #  перегородку
        #  -клик по перегородке удаляет перегородку
        #  -клик по роботу и перемещение мыши при неотпущенной клавише
        #  перемещает робота вслед за курсором в нужную клетку
        #  ( "неисправного" робота также можно "починить" таким способом )
        #После любого числа таких действий робот сразу готов к командному
        #управлению
        #
        #-------------------------------------------------------------
        #Если r.outside = 'none', то считается, что поле ограничено рамкой
        #     r.outside = 'ismark', то считается, что за пределами рамки сплошь установлены маркеры
        #     r.outside = 'nomark', то считается, что за пределами рамки исходно маркеров нет
        #
        #При r.outside не равном 'none' считается, что все перегородки, вплотную примыкающие к рамке поля
        #( которая в данном случае не рассматривается как ограждение ),
        #мыслятся продолженными до бесконечности в невидимую часть поля в соответствующих направлениях
        #( невидимая часть поля всегда остается невидимой )
        #
        #-------------------------------------------------------------
        #Сохранить результат РУЧНОГО редактирования обстановки на поле
        #можно с помощью комбинации клавиш CTRL+S
        #( при этом окно с роботом должно быть текущим! )
        #
        #Восстановить последнюю сохраненную обстановку на поле можно с помощью
        #комбинации клавиш CTRL+R ( при этом окно с роботом должно быть текущим! )
        #
        #Просмотреть значения температур клеток можно с помощью коьбинации клавиш
        #CRTL+T ( при этом окно с роботом должно быть текущим! )
        #Повторное нажатие этой комбинации клавиш убирает значения температур из
        #клеток
        #Визуализированные значения температур можно редактировать ( результаты редактирования
        #сохраняются только в опреративной памяти, для сохранения на диске
        #требуется CTRL+S )
        #
        #Динамически менять время задержки выполнения команд робота мможно с помощью
        #комбинации клавиш CTRL+"плюс" или CTRL+"минус", соответственно
        #( при этом окно с роботом должно быть текущим! )
        :param mapfile:
        """

        super().__init__(mapfile)

    def forward(self):
        """
        #forward - команда переместить робота вперед в соседнюю клетку
        #
        #СИНТАКСИС:
        #           r.forward( )
        #
        #ДАНО:
        # - r = ссылка на объект класса Rob_rot:
        #   робот в некотрой клетке поля, прямо по курсу робота
        #   перегородки нет
        #
        #РЕЗУЛЬТАТ:
        # - Робот в соседней по направлению side клетке ( если
        #   только на пути робота нет перегородки, в противном случае
        #   происходит "поломка" робота )
        :return:
        """

        try:
            self.robot_check()

            side = self.hRobotEngine.get_side_()

            self.hRobotEngine.step(side)
        except RobotException as e:
            eprint(e)

    def get_side(self):
        """
        #get_side - команда сообщить текущее направление робота
        #
        #СИНТАКСИС:
        #            side = r.get_side()
        #
        #ДАНО:
        # - r = ссылка на объект класса Rob_rot:
        #   робот в некотрой клетке
        #
        #РЕЗУЛЬТАТ:
        # - side = 'n' (Север) | 's' (Юг) | 'o' (Восток) | 'w' (Запад)
        #   - текущее направление робота
        #
        :return:
        """

        try:
            self.robot_check()
            return self.hRobotEngine.get_side()
        except RobotException as e:
            eprint(e)


class RobotOrt(RobotRelBase):
    """
    #Класс Rob_rel, каждый объект этого класса является
    #ссылкой ( handle ) на объект, представляющий ИСПОЛНИТЕЛЯ "ориентированнный робот на клетчатом поле"
    #
    #Командный интерфейс ( методы класса ):
    # forward, right, left, is_bord, mark, is_mark, get_side, get_tmpr
    #
    #Направление перемещения, поворотов и проверки наличия препятствия задаются
    #ОТНОСИТЕЛЬНО:
    #   шаг вперед; повернуть налево; повернуть направо;
    #   проверить, есть ли препятствие прямо по курсу
    #
    #См. также ПОХОЖИЙ класс Rob_rot
    #
    #-------------------------------------------------------------------------
    #Версия: 1.0*
    #Дата: 13.03.2013
    #-----------------------------------------------------------------------
    # Rob_rel - класс-оболочка класса Robot.Robot

    # % properties( Access = private )
    hField# ссылка на объект класса Robot.Robot (робот на клетчатом поле)
    #end


    # methods( Access = public )

    """

    def __init__(self, mapfile=None):
        """
        #Rob_rel - конструктор класса
        #
        #СИНТАКСИС:
        #       r = Rob_rel()
        #       r = Rob_rel( mapfile )
        #
        #В 1-ом случае открвается стандартное диалоговое окно для
        #выбора файла, в случае отказа, открывается диалог для
        #определения параметров поля
        #
        #Во 2-м случае:
        # - mapfile - имя файла, в котором сохранена обстановка на поле
        #
        #РЕЗУЛЬТАТ:
        # - r = ссылка ( handle ) на созданный объект класса Rob_rel
        #
        #-------------------------------------------------------------
        # Командный интерфейс робота ( методы класса ):
        #   forward, right, left, is_bord, mark, is_mark, get_side, get_tmpr
        #
        #-------------------------------------------------------------
        #Изменить ( установить или отредактировать ) начальную обстановку
        #на поле можно с помощью мыши:
        #  -клик по клетке устанавливает маркер
        #  -клик по маркеру удаляет маркер
        #  -клик по пунктирной линии сетки клетчатого поля устанавливает
        #  перегородку
        #  -клик по перегородке удаляет перегородку
        #  -клик по роботу и перемещение мыши при неотпущенной клавише
        #  перемещает робота вслед за курсором в нужную клетку
        #  ( "неисправного" робота также можно "починить" таким способом )
        #После любого числа таких действий робот сразу готов к командному
        #управлению
        #
        #-------------------------------------------------------------
        #Если r.outside = 'none', то считается, что поле ограничено рамкой
        #     r.outside = 'ismark', то считается, что за пределами рамки сплошь установлены маркеры
        #     r.outside = 'nomark', то считается, что за пределами рамки исходно маркеров нет
        #
        #При r.outside не равном 'none' считается, что все перегородки, вплотную примыкающие к рамке поля
        #( которая в данном случае не рассматривается как ограждение ),
        #мыслятся продолженными до бесконечности в невидимую часть поля в соответствующих направлениях
        #( невидимая часть поля всегда остается невидимой )
        #
        #-------------------------------------------------------------
        #Сохранить результат РУЧНОГО редактирования обстановки на поле
        #можно с помощью комбинации клавиш CTRL+S
        #( при этом окно с роботом должно быть текущим! )
        #
        #Восстановить последнюю сохраненную обстановку на поле можно с помощью
        #комбинации клавиш CTRL+R ( при этом окно с роботом должно быть текущим! )
        #
        #Просмотреть значения температур клеток можно с помощью коьбинации клавиш
        #CRTL+T ( при этом окно с роботом должно быть текущим! )
        #Повторное нажатие этой комбинации клавиш убирает значения температур из
        #клеток
        #Визуализированные значения температур можно редактировать ( результаты редактирования
        #сохраняются только в опреративной памяти, для сохранения на диске
        #требуется CTRL+S )
        #
        #Динамически менять время задержки выполнения команд робота мможно с помощью
        #комбинации клавиш CTRL+"плюс" или CTRL+"минус", соответственно
        #( при этом окно с роботом должно быть текущим! )

        :param mapfile:
        """

        super().__init__(mapfile)

    def init_data(self):
        """
        Initialize data
        :return:
        """
        self.hRobotEngine = RobotEngine(self.mapfile, 'RobotOrt')

    def left(self):
        """
        #left - команда развернуть робота влево
        #
        #СИНТАКСИС:
        #           r.left( )
        #
        #ДАНО:
        # - r = ссылка на объект класса Rob_rel:
        #   робот в некотрой клетке поля
        #
        #РЕЗУЛЬТАТ:
        # - Робот развёрнут влево на 90 градусов
        :return:
        """

        try:
            self.robot_check()

            self.hRobotEngine.rot('Left')
        except RobotException as e:
            eprint(e)

    def right(self):
        """
        #right - команда развернуть робота вправо
        #
        #СИНТАКСИС:
        #           r.right( )
        #
        #ДАНО:
        # - r = ссылка на объект класса Rob_rel:
        #   робот в некотрой клетке поля
        #
        #РЕЗУЛЬТАТ:
        # - Робот развёрнут вправо на 90 градусов
        :return:
        """

        try:
            self.robot_check()
            self.hRobotEngine.rot('Right')
        except RobotException as e:
            eprint(e)

    def is_bord(self):
        """
        #is_bord - команда проверить наличие перегородки впереди робота
        #
        #СИНТАКСИС:
        #          ansv = r.is_bord( )
        #
        #ДАНО:
        # - r = ссылка на объект класса Rob_rel:
        #   робот в некотрой клетке поля
        #
        #РЕЗУЛЬТАТ:
        # - ansv = 1 ( True ), eсли в направлении side есть перегородка
        #        = 0 ( False ) - в противном случае
        :return:
        """

        try:
            self.robot_check()

            side = self.hRobotEngine.get_side_()

            return self.hRobotEngine.is_bord(side)
        except RobotException as e:
            eprint(e)


class RobotRot(RobotRelBase):
    """
    #Класс Rob_rot, каждый объект этого класса является
    #ссылкой ( handle ) на объект, представляющий
    #   ИСПОЛНИТЕЛЯ "ориентированнный робот на клетчатом поле"
    #
    #Командный интерфейс ( методы класса ):
    # forward, rot, is_bord, mark, is_mark, get_side, get_tmpr
    #
    #Направление перемещения, поворотов и проверки наличия препятствия задаются
    #ОТНОСИТЕЛЬНО:
    #   шаг вперед; повернуть налево; повернуть направо;
    #   проверить, есть ли препятствие прямо по курсу, слева, справа
    #
    #************************************************************************
    #ОТЛИЧАЕТСЯ от класса Rob_rel тем, что вместо двух методов Rob_rel\Left и
    #Rob_rel\Right в классе Rob_rot имеется лишь один метод rot, но с параметром,
    #который может принимать 3 значения: 'left', 'right', 'back' (или 'l',
    #'r','b')
    #а также тем, что метод Rob_rot\is_bord имеет параметр, который может
    #принимать также 3 значения: 'forward', 'left', 'right'
    #
    #-------------------------------------------------------------------------
    #Версия: 1.0*
    #Дата: 13.03.2013
    #-----------------------------------------------------------------------


    # Rob_rot - класс-оболочка класса Robot.Robot( )

    # % properties( Access = private )
    #hField# ссылка на объект класса Robot.Robot (робот на клетчатом поле)
    #end
    """

    def __init__(self, mapfile=None):
        """
        #Rob_rot - конструктор класса
        #
        #СИНТАКСИС:
        #       r = Rob_rot()
        #       r = Rob_rot( mapfile )
        #
        #В 1-ом случае открвается стандартное диалоговое окно для
        #выбора файла, в случае отказа, открывается диалог для
        #определения параметров поля
        #
        #Во 2-м случае:
        # - mapfile - имя файла, в котором сохранена обстановка на поле
        #
        #РЕЗУЛЬТАТ:
        # - r = ссылка ( handle ) на созданный объект класса Rob_rot
        #
        #-------------------------------------------------------------
        # Командный интерфейс робота ( методы класса ):
        #   forward, rot, is_bord, mark, is_mark, get_side, get_tmpr
        #
        #-------------------------------------------------------------
        #Изменить ( установить или отредактировать ) начальную обстановку
        #на поле можно с помощью мыши:
        #  -клик по клетке устанавливает маркер
        #  -клик по маркеру удаляет маркер
        #  -клик по пунктирной линии сетки клетчатого поля устанавливает
        #  перегородку
        #  -клик по перегородке удаляет перегородку
        #  -клик по роботу и перемещение мыши при неотпущенной клавише
        #  перемещает робота вслед за курсором в нужную клетку
        #  ( "неисправного" робота также можно "починить" таким способом )
        #После любого числа таких действий робот сразу готов к командному
        #управлению
        #
        #-------------------------------------------------------------
        #Если r.outside = 'none', то считается, что поле ограничено рамкой
        #     r.outside = 'ismark', то считается, что за пределами рамки сплошь установлены маркеры
        #     r.outside = 'nomark', то считается, что за пределами рамки исходно маркеров нет
        #
        #При r.outside не равном 'none' считается, что все перегородки, вплотную примыкающие к рамке поля
        #( которая в данном случае не рассматривается как ограждение ),
        #мыслятся продолженными до бесконечности в невидимую часть поля в соответствующих направлениях
        #( невидимая часть поля всегда остается невидимой )
        #
        #-------------------------------------------------------------
        #Сохранить результат РУЧНОГО редактирования обстановки на поле
        #можно с помощью комбинации клавиш CTRL+S
        #( при этом окно с роботом должно быть текущим! )
        #
        #Восстановить последнюю сохраненную обстановку на поле можно с помощью
        #комбинации клавиш CTRL+R ( при этом окно с роботом должно быть текущим! )
        #
        #Просмотреть значения температур клеток можно с помощью коьбинации клавиш
        #CRTL+T ( при этом окно с роботом должно быть текущим! )
        #Повторное нажатие этой комбинации клавиш убирает значения температур из
        #клеток
        #Визуализированные значения температур можно редактировать ( результаты редактирования
        #сохраняются только в опреративной памяти, для сохранения на диске
        #требуется CTRL+S )
        #
        #Динамически менять время задержки выполнения команд робота мможно с помощью
        #комбинации клавиш CTRL+"плюс" или CTRL+"минус", соответственно
        #( при этом окно с роботом должно быть текущим! )
        :param mapfile:
        """

        super().__init__(mapfile)

    def init_data(self):
        """
        Initialize data
        :return:
        """
        self.hRobotEngine = RobotEngine(self.mapfile, 'RobotRot')

    def rot(self, side=None):
        """
        #rot - команда развернуть робота налево, направо или назад
        #
        #СИНТАКСИС:
        #           r.rot( side )
        #
        #ДАНО:
        # - r = ссылка на объект класса Rob_rot:
        #   робот в некотрой клетке поля
        # - side = 'l' ('left') | 'r' ('right') | 'b' ('back')
        #РЕЗУЛЬТАТ:
        # - Робот развёрнут влево на 90 градусов
        :param side:
        :return:
        """

        try:
            self.robot_check()

            self.hRobotEngine.rot(side)
        except RobotException as e:
            eprint(e)

    def is_bord(self, side=None):
        """
        #is_bord - команда проверить наличие перегородки в заданном направлении
        #
        #СИНТАКСИС:
        #          ansv = r.is_bord( side )
        #
        #ДАНО:
        # - r = ссылка на объект класса Rob_rot:
        #   робот в некотрой клетке поля
        # - side = 'forward' ('f') | 'left' ('l') | 'right' ('r')
        #
        #РЕЗУЛЬТАТ:
        # - ansv = 1 ( true ), eсли в направлении side есть перегородка
        #        = 0 ( false ) - в противном случае
        """

        try:
            self.robot_check()

            abs_side = self.hRobotEngine.get_side_()

            abs_side = encode_side(abs_side)

            if side:
                side = str.upper(side)
            else:
                raise SideRotValueError

            if side in ('LEFT', 'L'):
                abs_side = (abs_side - 1) % 4
            elif side in ('RIGHT', 'R'):
                abs_side = (abs_side + 1) % 4
            elif side in ('FORWARD', 'F'):
                # направление остается прежним
                pass
            else:
                raise SideRotValueError

            abs_side = decode_side(abs_side)

            return self.hRobotEngine.is_bord(abs_side)
        except RobotException as e:
            eprint(e)
